# unmapped.py
# -*- coding: utf-8 -*-

# PURPOSE:    This module serves 3 main criteria:
# (1) Generates function clusters, based on the DB-Scan (density based, spatial clustering of
# applications with noise) algorithm.
# (2) Reports the Euclidean distance between points in each cluster.
# (3) Displays both the original clusters of unmapped points and the average co-ordinates, with a
# polynomial function fitted.


# Library imports
import pandas as pd
import operator
from os import getcwd

from bokeh.transform import factor_cmap
from bokeh.transform import factor_mark
from bokeh.models import Range1d
from bokeh.models import ColumnDataSource
from bokeh.plotting import figure
from bokeh.io import output_file
from bokeh.io import save
from bokeh.palettes import Spectral11

from sklearn.cluster import DBSCAN
from sklearn.preprocessing import PolynomialFeatures
from sklearn.linear_model import LinearRegression

# Imports own modules
from test import TestFunctionReturner
from arithmetic import calc_diff
from arithmetic import square_number
from arithmetic import calc_square_root
from arithmetic import sum_array
from arithmetic import norm_root_mean_squared_error

graphs_directory = getcwd() + '/additional_graphs/'


class UnmappedClusters(TestFunctionReturner):
    """
    Re-examines the test functions that are still unmapped at square root 6.
    It inputs these to a DB-Scan algorithm to generate clusters within the functions.
    It reports the Euclidean distance between points in each cluster.
    It creates graphs of the original clusters of unmapped points, as well as the average cluster
    co-ordinates with a third-degree polynomial function fitted.
    Inputs:
        sq_root_number (int) - this is defaulted to 6 for the analysis.
        train_df, ideal_df, test_df inherited from TestFunctionReturner.
    Outputs:
        printed Euclidean distance table
        Bokeh graphs of original clusters and

    """
    # Initiates new constructor
    def __init__(self, train_df, ideal_df, test_df, sq_root_number=6):
        # Calls parent's (TrainFunctionReturner) constructor
        super().__init__(train_df, ideal_df, test_df, sq_root_number)
        # Assigns the square root attribute to 6
        self.sq_root_number = sq_root_number

    def _clustered_df(self, filter_noise=False):
        """
        Appends the cluster number generated by running the DB-Scan algorithm.
        Input:
            No explicit input but uses the unmapped functions set from test.
            Optionally specify if noisy data (i.e. points not belonging to a cluster), should
            be omitted/filtered.
        Output:
            _df (dataframe) - unmapped functions dataframe with cluster number
        """
        _df = self.unmapped_fns_set().reset_index()
        # DBSCAN with epsilon is instantiated at a high number due to the distance between points
        # This is offset slightly by min samples = 2
        dbscan = DBSCAN(eps=500, min_samples=2).fit(_df[['x', 'y_test_func']])
        _df['dbscan_labels'] = dbscan.labels_

        # Labels are int, need to recast to string
        _df['dbscan_labels'] = _df['dbscan_labels'].astype('str')

        # Optionally exclude points not falling into a cluster
        if filter_noise:
            _df = _df[_df['dbscan_labels'] != '-1']
        _df = _df.sort_values(by=['dbscan_labels'])
        _df = _df.reset_index(drop=True)
        return _df

    def _euclidean_dist(self, x, y):
        """
        Calculates the Euclidean distance within points in a function.
        Calculation based from Pythagorean theorem.
        Inputs:
            x, y: function co-ordinates
        Outputs:
            Euclidean distance
        """
        square_diff = square_number(calc_diff(x, y))
        sqrt_sum = calc_square_root(sum_array(square_diff))
        return sqrt_sum

    def print_euclidean_dist(self):
        """
        Prints the Euclidean distance between the points within the same cluster.
        Input:
            No explicit input but uses the _clustered_df.
        Output:
            Print of cluster number mapped to Euclidean distance.
        """
        clustered_df = self._clustered_df()
        _my_list_i, _my_list_ii = [], []
        for cluster_num in clustered_df['dbscan_labels'].unique():
            if cluster_num == '-1':
                continue
            else:
                _df = clustered_df.loc[clustered_df['dbscan_labels'] == cluster_num][['x', 'y_test_func']]
                x = _df['x'].values
                y = _df['y_test_func'].values
                dist = self._euclidean_dist(x, y)
                _my_list_i.append(cluster_num)
                _my_list_ii.append(dist)
        print('-' * 41)
        print(f'{"Euclidean Distances between Clusters": ^41}')
        print('-' * 41)
        for x, y in zip(_my_list_i, _my_list_ii):
            y = '{0:.2f}'.format(y)
            print(f'{"Cluster "}{x}{":":^24s}{y:>6s}')

    def original_cluster_display(self):
        """
        Saves a Bokeh scatter plot of unmapped points, colour-coded to their respective
        cluster numbers.
        Input:
            No explicit input but uses the clustered_df.
        Output:
            original_unmapped_clusters.html
        """
        clustered_df = self._clustered_df()
        _title = "Clustering of unmapped points (cluster -1 denotes un-clustered points)"
        data = ColumnDataSource(clustered_df)
        leg_ent = sorted(clustered_df['dbscan_labels'].unique().tolist())
        shp_marker = ['circle']

        p = figure(title=_title, width=1000, height=750)
        p.title.text_font_size = "14px"
        p.xaxis.axis_label = 'x'
        p.yaxis.axis_label = 'y'

        p.scatter("x", "y_test_func", source=data,
                  legend_group="dbscan_labels", size=10,
                  marker=factor_mark('dbscan_labels', shp_marker, leg_ent),
                  color=factor_cmap('dbscan_labels', 'Spectral11', leg_ent))

        p.add_layout(p.legend[0], 'right')
        p.x_range = Range1d(-50, 50)
        p.legend.title = "cluster number"

        output_file(graphs_directory + 'original_unmapped_clusters.html')
        save(p)

    def _cluster_centers(self):
        """
        Calculates the average x and y co-ordinates, per cluster in clustered_df.
        Will not represent points identified as noise.
        Input:
            No explicit input but uses the clustered_df.
        Output:
            _df (dataframe) - cluster number with average x, y co-ordinates.
        """
        # Calculates the cluster centers using the average of points comprising the cluster
        clustered_df = self._clustered_df(True)
        x_bar, y_bar = [], []
        for label in clustered_df['dbscan_labels'].unique():
            _df = clustered_df[clustered_df['dbscan_labels'] == label]
            _df['x_bar'] = _df['x'].mean()
            _df['y_bar'] = _df['y_test_func'].mean()
            x_bar.append(_df['x_bar'].values)
            y_bar.append(_df['y_bar'].values)

        x_bar = [i for values in x_bar for i in values]
        y_bar = [i for values in y_bar for i in values]

        clustered_df['x_bar'] = x_bar
        clustered_df['y_bar'] = y_bar
        clustered_df = clustered_df[['dbscan_labels', 'x_bar', 'y_bar']]

        # Recursively recreates the smaller df of cluster centers
        _df = pd.DataFrame(columns=['dbscan_labels', 'x_bar', 'y_bar'])
        for col_num in range(len(clustered_df.columns)):
            this_column = _df.columns[col_num]
            uni = pd.unique(clustered_df[this_column])
            _df[this_column] = uni
        return _df

    def polynomial_display(self):
        """
        Saves a Bokeh graph of unmapped points' centroids, with best-fitting polynomial line.
        Normalised RMSE also calculated and displayed
        Input:
            No explicit input but uses cluster_centers.
        Output:
            polynomial_line_unmapped_clusters.html
        """
        cluster_centers = self._cluster_centers()
        x = cluster_centers['x_bar'].values.reshape(len(cluster_centers.index.values), 1)
        y = cluster_centers['y_bar'].values

        # Creates polynomial features
        poly_feat = PolynomialFeatures(3)

        # Creates a PolynomialFeatures object, then fit and transform the predictor feature
        x_poly = poly_feat.fit_transform(x)

        # Creates a LinearRegression object and fit it to the polynomial predictor features
        poly_model = LinearRegression(fit_intercept=False)
        poly_model = poly_model.fit(x_poly, y)

        # Predicts the y co-ordinates based on the model
        y_poly_pred = poly_model.predict(x_poly)

        # Generates the normalised root mean squared error for the model
        n_rmse = norm_root_mean_squared_error(y, y_poly_pred)
        n_rmse = '{0:.2f}'.format(n_rmse)

        # Plots original x, y centroids
        x_ = x.tolist()
        x = [x for val in x_ for x in val]

        _title = "Clustered unmapped points with 3rd degree polynomial line fitted." \
                 " Normalised RMSE: " + n_rmse
        p = figure(width=1000, height=750, title=_title)
        p.title.text_font_size = "14px"
        p.circle(x, y, size=10, color=Spectral11[1])
        p.xaxis.axis_label = 'x'
        p.yaxis.axis_label = 'y'

        # Sorts the values of x before line plot
        sort_axis = operator.itemgetter(0)
        sorted_zip = sorted(zip(x, y_poly_pred), key=sort_axis)
        x, y_poly_pred = zip(*sorted_zip)
        p.line(x, y_poly_pred, line_width=2, color=Spectral11[3])
        output_file(graphs_directory + 'polynomial_line_unmapped_clusters.html')
        save(p)
